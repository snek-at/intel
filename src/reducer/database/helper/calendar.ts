//#region > Imports
//#PACKAGE "moment"
//## npm install "moment"@2.25.3
// A lightweight JavaScript date library for parsing,
// validating, manipulating, and formatting dates.
import moment, { Moment } from "moment";
//#endregion

//#region > Interfaces
/** @interface Calendar defines the structure of the calendar object */
interface ICalendar {
  /**
   *  StartDate: The date a calendar object starts with.
   */
  startDate: Moment;
  /**
   *  EndDate: The date a calendar object ends with.
   */
  endDate: Moment;
  /**
   *  Weeks: Contains a list of week objects.
   */
  weeks: IWeek[];
}

/** @interface Week defines the structure of the week object */
interface IWeek {
  /**
   * Days: Contains a list of day objects.
   */
  days: IDay[];
}

/** @interface Day defines the structure of the day object */
interface IDay {
  /**
   * Date: The date of a day object.
   */
  date: string;
  /**
   *  Color: The color of a day object.
   */
  color: string;
  /**
   *  Total: The total contribution amount of a day object.
   */
  total: number;
}
//#endregion

//#region > Functions
/**
 * Generate calendar object containing weeks with days.
 *
 * @function
 * @param startDate A date on which the calendar should start
 * @param endDate A date on which the calendar should end
 * @returns {object} A calendar object with a structure containing weeks with
 *                   empty days.
 * @description Generates a calendar object containing empty days from
 *              startDate to endDate.
 */
function generateCalendarStructure(startDate: string, endDate: string) {
  let weeks: IWeek[] = [{ days: [] }];

  for (
    let m = moment(startDate);
    
    m.diff(endDate, "days") <= 0;
    m.add(1, "days")
  ) {
    if (weeks[weeks.length - 1].days.length > 6) {
      weeks.push({
        days: [],
      });
    }

    let day: IDay = {
      date: m.format("YYYY-MM-DD"),
      color: "#ebedf0",
      total: 0,
    };

    weeks[weeks.length - 1].days.push(day);
  }

  let calendar = {
    startDate: moment(startDate),
    endDate: moment(endDate),
    weeks,
  } as ICalendar;

  return calendar;
}

/**
 * Fill all days of a calendar object with colors.
 *
 * @param calendar Calendar object generated by "generateCalendarStructure"
 * @param busiestDayTotal The total amount of contributions for calculating the
 *                        color spectrum.
 * @returns {object} A calendar object where all days have a specific color based
 *                   on their contributions.
 */
function fillCalendarWithColors(calendar: ICalendar, busiestDayTotal: number) {
  calendar.weeks.forEach((week) => {
    week.days.forEach((day) => {
      const precision = day.total / busiestDayTotal;

      if (precision > 0.8 && precision <= 1) {
        day.color = "#196127";
      } else if (precision > 0.6 && precision <= 0.8) {
        day.color = "#239a3b";
      } else if (precision > 0.4 && precision <= 0.6) {
        day.color = "#7bc96f";
      } else if (precision > 0.0 && precision <= 0.4) {
        day.color = "#c6e48b";
      } else if (precision === 0) {
        day.color = "#ebedf0";
      }
    });
  });

  return calendar;
}
//#endregion

//#region > Exports
// Interface
export type { ICalendar };
// Functions
export { generateCalendarStructure, fillCalendarWithColors };
//#endregion

/**
 * SPDX-License-Identifier: (EUPL-1.2)
 * Copyright Â© 2019-2020 Simon Prast
 */
